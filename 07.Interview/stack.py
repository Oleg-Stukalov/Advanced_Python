"""Стек - абстрактный тип данных, представляющий собой список элементов, организованных по принципу
LIFO(англ.last in — first out, «последним пришёл — первым вышел»). Чаще всего принцип работы стека сравнивают
со стопкой тарелок: чтобы взять вторую сверху, нужно снять верхнюю. Или с магазином в огнестрельном оружии
(стрельба начнётся с патрона, заряженного последним).

1. Необходимо реализовать класс Stack со следующими методами:
    - isEmpty - проверка стека на пустоту. Метод возвращает True или False.
    - push - добавляет новый элемент на вершину стека. Метод ничего не возвращает.
    - pop - удаляет верхний элемент  стека. Стек изменяется. Метод возвращает верхний элемент стека.
    - peek - возвращает верхний элемент стека, но не удаляет его. Стек не меняется.
    - size - возвращает количество элементов в стеке.

2. Используя стек из задания 1 необходимо решить задачу на проверку сбалансированности скобок.
Сбалансированность скобок означает, что каждый открывающий символ имеет соответствующий ему закрывающий, и пары
скобок правильно вложены друг в друга.

Сбалансированными последовательности будут следующие скобки:
    - (((([{}]))))
    - [([])((([[[]]])))]{()}
    - {{[()]}}

Несбалансированными последовательности:
    - }{}
    - {{[(])]}}
    - [[{())}]

Программа ожидает на вход строку с скобками. На выход сообщение "Сбалансированно", если строка корректная
и "Небалансированно", если строка составлена неверно."""

import random


class Stack:
    PARENTHESES: dict = {'(': ')',
                         '[': ']',
                         '{': '}'}

    stack: list = list()

    def size(self) -> int:
        """Проверка текущего размера стека """
        return len(self.stack)

    def is_empty(self) -> bool:
        """Проверка стека на пустоту"""
        return self.size() == 0

    def push(self, elem: str) -> None:
        """Добавление нового элемента на стек """
        self.stack.append(elem)

    def pop(self) -> str:
        """Добавление последнего элемента со стека """
        return self.stack.pop()

    def peek(self) -> str:
        """Проверка последнего элемента на стеке"""
        if self.size():
            return self.stack[-1]

    def check(self, string: str) -> str:
        """Проверка сбалансированности строк"""
        for elem in string:
            if elem == string[0] and elem in self.PARENTHESES.values():
                return f"{string} - не cбалансировано"
            elif elem in self.PARENTHESES.keys():
                self.push(elem)
            elif elem in self.PARENTHESES.values():
                if self.PARENTHESES.get(self.peek()) == elem:
                    self.pop()
                else:
                    return f"{string} - не cбалансировано"
            if self.is_empty() is True:
                return f"{string} - сбалансировано"


if __name__ == '__main__':
    lines: list = [
        '(((([{}]))))',
        '[([])((([[[]]])))]{()}',
        '{{[()]}}',
        '}{}',
        '{{[(])]}}',
        '[[{())}]',
    ]
    stack: Stack = Stack()

    print()
    print('Прямой порядок строк')
    print(*lines)
    for line in lines:
        print(stack.check(line))

    print()
    random.shuffle(lines)

    print('Перемешанные строки')
    print(*lines)
    for line in lines:
        print(stack.check(line))

    # Почему при перемешивании строк через shuffle некоторые из них не попадают в вывод?
    # Например:

    # None
    # }{} - не cбалансировано
    # None
    # [[{())}] - не cбалансировано
    # None
    # {{[(])]}} - не cбалансировано
